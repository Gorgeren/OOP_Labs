
#ifndef LAB1_TBINARYTREE_H
#define LAB1_TBINARYTREE_H
#include "tbinarytreeitem.h"
// В каждой вершине двоичного дерева хранится фигура и счетчик.
// Если в структуру добавляется фигура, которая уже есть,
// счетчик инкрементируется.
class TBinaryTree {
 public:
 // Конструктор по умолчанию.
 TBinaryTree();
 // Метод добавления фигуры согласно правилу:
 // При добавлении фигуры в новую вершину, 
 // в вершине создается счетчик со значением 1.
 // Если фигура совпадает с фигурой из вершины,
 // счетчик в вершине увеличивается на 1.
 // Иначе сравнивается с вершиной из левого поддерева,
 // если площадь фигуры < площади в вершине
 // или с вершиной правого поддерева, если >=.
 void Push(Rhombus& Rhombus);
 // Метод получения фигуры из контейнера.
 // Если площадь превышает максимально возможную,
 // метод должен бросить исключение std::out_of_range
 const Rhombus& GetItemNotLess(double area);
 // Метод, возвращающий количество совпадающих фигур с данными параметрами
 size_t Count( Rhombus& Rhombus);
 // Метод по удалению фигуры из дерева:
 // Счетчик вершины уменьшается на единицу.
 // Если счетчик становится равен 0,
 // вершина удаляется с заменой на корректный узел поддерева.
 // Если такой вершины нет, бросается исключение std::invalid_argument
 void Pop( Rhombus &Rhombus);
 // Метод проверки наличия в дереве вершин
 bool Empty();
 // Оператор вывода дерева в формате вложенных списков,
 // где каждый вложенный список является поддеревом текущей вершины:
 // "S0: [S1: [S3, S4: [S5, S6]], S2]",
 // где Si - строка вида количество*площадь_фигуры
 // Пример: 1*1.5: [3*1.0, 2*2.0: [2*1.5, 1*6.4]]
 friend std::ostream& operator<<(std::ostream& os, const TBinaryTree& tree);
 // Метод, удаляющий все элементы контейнера,
 // но позволяющий пользоваться им.
 void Clear();
 // Деструктор
 virtual ~TBinaryTree();
 private:
    TreeItem* root;
};
#endif